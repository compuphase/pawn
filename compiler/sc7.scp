/*  Pawn compiler - Peephole optimizer "sequences" strings (plain
 *                  and compressed formats)
 *
 *  Copyright (c) ITB CompuPhase, 2000-2016
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not
 *  use this file except in compliance with the License. You may obtain a copy
 *  of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  License for the specific language governing permissions and limitations
 *  under the License.
 *
 *  Version: $Id: sc7.sch 5579 2016-09-12 07:58:43Z  $
 */

/* Special characters in the strings of this file:
 *  %1 to %5    Parameters that are replaced, the parameters should be numerical
 *              (hexadecimal) values (exceptionally, an alphanumeric symbol).
 *  %0          A parameter that is replaced with its packed value (so on a
 *              32-bit system, 00001234 gets replaced by 1234).
 *  -           In front of a parameter, - means that the parameter is replaced
 *              by the negated value from the source; this token is valid only
 *              in the replacement string.
 *  +           Between two parameters, + means that the parameters are replaced
 *              by the sum; this token is valid only in the replacement string.
 *  ~           In front of a parameter, and optional space, which should precede
 *              an optional variable.
 *  #           In front of a literal value, the expanded hexadecimal version of
 *              that literal value (so #5 becomes 00000005 on a 32-bit system);
 *              this token is valid only in the replacement string.
 */

SC_FUNC int strexpand(char *dest, const unsigned char *source, int maxlen, const unsigned char pairtable[128][2]);

#define SCPACK_TERMINATOR ,     /* end each section with a comma */

#define SCPACK_TABLE sequences_table
/*-*SCPACK start of pair table, do not change or remove this line */
const unsigned char sequences_table[][2] = {
  {105,32}, {114,128}, {112,129}, {46,130}, {49,33}, {37,132}, {32,37}, {97,100}, {115,104}, {117,136}, {112,137}, {46,115}, {59,36}, {32,133}, {108,111}, {50,33},
  {142,135}, {97,108}, {145,116}, {46,146}, {46,112}, {105,33}, {131,133}, {114,33}, {131,37}, {97,151}, {112,153}, {140,154}, {115,116}, {144,139}, {46,99}, {114,149},
  {148,159}, {48,33}, {152,143}, {134,143}, {135,100}, {110,156}, {111,165}, {99,166}, {147,33}, {112,111}, {169,112}, {138,114}, {112,33}, {120,172}, {101,173}, {140,174},
  {134,161}, {134,51}, {138,160}, {170,168}, {134,49}, {147,141}, {157,162}, {126,37}, {177,33}, {103,33}, {104,185}, {99,186}, {120,187}, {164,114}, {46,135}, {122,101},
  {190,114}, {191,114}, {101,113}, {155,138}, {167,150}, {46,149}, {110,100}, {52,33}, {32,35}, {105,110}, {201,99}, {101,99}, {100,203}, {155,171}, {141,175}, {157,150},
  {53,33}, {164,33}, {194,33}, {138,109}, {189,150}, {134,199}, {144,150}, {108,158}, {134,50}, {106,193}, {105,100}, {115,103}, {115,108}, {218,120}, {180,163}, {147,163},
  {178,182}, {117,198}, {136,215}, {111,225}, {98,227}, {114,101}, {229,102}, {193,111}, {228,115}, {181,182}, {180,216}, {217,141}, {144,162}, {232,184}, {179,209}, {108,230},
  {139,141}, {138,158}, {171,109}, {198,33}, {170,160}, {152,161}, {156,111}, {246,114}, {97,243}, {183,50}, {183,51}, {134,48}, {139,176}, {147,176}, {234,177}
};
/*-*SCPACK end of pair table, do not change or remove this line */

typedef struct {
  const char *find;
  const char *replace;
  short opc,arg;        /* number of opcodes/arguments saved (may be negative!) */
} SEQUENCE;
static const char separator_macro[] = {sOPTIMIZE_MACRO,'\0'};
static const char separator_full[] = {sOPTIMIZE_FULL,'\0'};
static const SEQUENCE sequences_cmp[] = {
  /* A very common sequence in four varieties
   *    load.s.pri %1           load.s.pri %2
   *    push.pri                load.s.alt %1
   *    load.s.pri %2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri %1             load.s.pri %2
   *    push.pri                load.alt %1
   *    load.s.pri %2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.s.pri %1           load.pri %2
   *    push.pri                load.s.alt %1
   *    load.pri %2             -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri %1             load.pri %2
   *    push.pri                load.alt %1
   *    load.pri %2             -
   *    pop.alt                 -
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\317\340\263",
      "\266\235\265",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\326\340\263",
      "\266\220\265",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\317\262\354\263",
      "\354\235\265",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.alt %1!",
    #else
      "\326\262\354\263",
      "\354\220\265",
    #endif
    4-2, 2-2
  },
  /* (#1#) The above also occurs with "addr.pri" (array
   * indexing) as the first line; so that adds 2 cases.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "addr.alt %1!load.s.pri %2!",
    #else
      "\324\340\263",
      "\275\351",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.pri %2!pop.alt!",
      "addr.alt %1!load.pri %2!",
    #else
      "\324\262\354\263",
      "\275\265\354",
    #endif
    4-2, 2-2
  },
  /* And the same sequence with const.pri as either the first
   * or the second load instruction: four more cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\304\340\263",
      "\266\247\265",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!const.alt %1!",
    #else
      "\304\262\354\263",
      "\354\247\265",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\317\262\247\242\263",
      "\247\242\235\265",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.alt %1!",
    #else
      "\326\262\247\242\263",
      "\247\242\220\265",
    #endif
    4-2, 2-2
  },
  /* The same as above, but now with "addr.pri" (array
   * indexing) on the first line and const.pri on
   * the second.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!const.pri %2!pop.alt!",
      "addr.alt %1!const.pri %2!",
    #else
      "\324\262\247\242\263",
      "\275\265\247\242",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!zero.pri!pop.alt!",
      "addr.alt %1!zero.pri!",
    #else
      "\324\262\347\240\263",
      "\275\265\347\240",
    #endif
    4-2, 1-1
  },
  /* ??? add references */
  /* Chained relational operators can contain sequences like:
   *    xchg                    load.s.pri %1
   *    push.pri                -
   *    load.s.pri %1           -
   *    pop.alt                 -
   * The above also accurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "xchg!push.pri!load.s.pri %1!pop.alt!",
      "load.s.pri %1!",
    #else
      "\274\262\317\263",
      "\317",
    #endif
    4-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!push.pri!load.pri %1!pop.alt!",
      "load.pri %1!",
    #else
      "\274\262\326\263",
      "\326",
    #endif
    4-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!push.pri!const.pri %1!pop.alt!",
      "const.pri %1!",
    #else
      "\274\262\304\263",
      "\304",
    #endif
    4-1, 1-1
  },
  /* More optimizations for chained relational operators; the
   * continuation sequences can be simplified if they turn out
   * to be termination sequences:
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     ;$exp
   *    pop.alt                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     jzer %1
   *    pop.alt                 -
   *    jzer %1                 -
   */
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!;$exp!",
      "sless!pop.alt!and!;$exp!",
    #else
      "\274\333rt\227swap\250\370\263\257",
      "\334ess!\263\370\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!;$exp!",
      "sgrtr!pop.alt!and!;$exp!",
    #else
      "\274\334ess!swap\250\370\263\257",
      "\333rt\227\263\370\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!;$exp!",
      "sleq!pop.alt!and!;$exp!",
    #else
      "\274\333\322swap\250\370\263\257",
      "\334\322\263\370\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!;$exp!",
      "sgeq!pop.alt!and!;$exp!",
    #else
      "\274\334\322swap\250\370\263\257",
      "\333\322\263\370\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!jzer %1!",
      "sless!pop.alt!and!jzer %1!",
    #else
      "\274\333rt\227swap\250\370\263\353",
      "\334ess!\263\370\353",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!jzer %1!",
      "sgrtr!pop.alt!and!jzer %1!",
    #else
      "\274\334ess!swap\250\370\263\353",
      "\333rt\227\263\370\353",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!jzer %1!",
      "sleq!pop.alt!and!jzer %1!",
    #else
      "\274\333\322swap\250\370\263\353",
      "\334\322\263\370\353",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!jzer %1!",
      "sgeq!pop.alt!and!jzer %1!",
    #else
      "\274\334\322swap\250\370\263\353",
      "\333\322\263\370\353",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!;$exp!",
      "sless!;$exp!",
    #else
      "\274\333rt\227\257",
      "\334ess!\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!;$exp!",
      "sgrtr!;$exp!",
    #else
      "\274\334ess!\257",
      "\333rt\227\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!;$exp!",
      "sleq!;$exp!",
    #else
      "\274\333\322\257",
      "\334\322\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!;$exp!",
      "sgeq!;$exp!",
    #else
      "\274\334\322\257",
      "\333\322\257",
    #endif
    2-1, 0-0
  },
  /* The entry to chained operators is also opt to optimization
   *    load.s.pri %1           load.s.pri %2
   *    load.s.alt %2           load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri %1           load.pri %2
   *    load.alt %2             load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri %1           const.pri %2
   *    const.alt %2            load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   * and all permutations...
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\317\235\337\274",
      "\266\235\265",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\317\220\337\274",
      "\354\235\265",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\317\247\337\274",
      "\247\242\235\265",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\326\235\337\274",
      "\266\220\265",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.alt %1!",
    #else
      "\326\220\337\274",
      "\354\220\265",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.alt %1!",
    #else
      "\326\247\337\274",
      "\247\242\220\265",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\304\235\337\274",
      "\266\247\265",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!xchg!",
      "load.pri %2!const.alt %1!",
    #else
      "\304\220\337\274",
      "\354\247\265",
    #endif
    3-2, 2-2
  },
  /* some sequences where PRI is moved to ALT can be optimized
   * further when considering what follows
   *    xchg                    const.alt %1
   *    const.pri %1            -
   *    xchg                    -
   * (also for load.s.pri and load.pri)
   *    --------------------------------------
   *    lref.pri %1             lref.alt %1
   *    xchg                    [load.pri %2]
   *    [load.pri %2]           -
   * (where [load.pri %2] may also be another operatrion loading PRI)
   */
  {
    #ifdef SCPACK
      "xchg!const.pri %1!xchg!",
      "const.alt %1!",
    #else
      "\274\304\274",
      "\247\265",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!xchg!",
      "load.alt %1!",
    #else
      "\274\326\274",
      "\220\265",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!xchg!",
      "load.s.alt %1!",
    #else
      "\274\317\274",
      "\235\265",
    #endif
    3-1, 1-1
  },
  /* ----- */
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!load.pri %2!",
      "lref.alt %1!load.pri %2!",
    #else
      "\357\226\274\354",
      "\357\265\354",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!load.s.pri %2!",
      "lref.alt %1!load.s.pri %2!",
    #else
      "\357\226\274\266",
      "\357\351",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!const.pri %2!",
      "lref.alt %1!const.pri %2!",
    #else
      "\357\226\274\247\242",
      "\357\265\247\242",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!load.pri %2!",
      "lref.s.alt %1!load.pri %2!",
    #else
      "\357\213\226\274\354",
      "\357\213\265\354",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!load.s.pri %2!",
      "lref.s.alt %1!load.s.pri %2!",
    #else
      "\357\213\226\274\266",
      "\357\213\351",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!const.pri %2!",
      "lref.s.alt %1!const.pri %2!",
    #else
      "\357\213\226\274\247\242",
      "\357\213\265\247\242",
    #endif
    3-2, 2-2
  },
  /* For packed arrays, array access can be optimized (packed arrays
   * do not take advantage of the LIDX or IDXADDR instructions).
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               -
   *    pop.alt                 -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent, but that
   *    case is already handled (see #1#)
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "addr.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\324\340\355\263",
      "\275\351\355",
    #endif
    5-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "const.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\304\340\355\263",
      "\247\351\355",
    #endif
    5-3, 3-3
  },
  /* During a calculation, the intermediate result must sometimes
   * be moved from PRI to ALT, like in:
   *    push.pri                xchg
   *    load.s.pri %1           load.s.pri %1
   *    pop.alt                 -
   *
   * The above also accurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!pop.alt!",
      "xchg!load.s.pri %1!",
    #else
      "\262\317\263",
      "\274\317",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!load.pri %1!pop.alt!",
      "xchg!load.pri %1!",
    #else
      "\262\326\263",
      "\274\326",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!pop.alt!",
      "xchg!const.pri %1!",
    #else
      "\262\304\263",
      "\274\304",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!zero.pri!pop.alt!",
      "xchg!zero.pri!",
    #else
      "\262\347\240\263",
      "\274\347\240",
    #endif
    3-2, 0-0
  },
  /* An even simpler PUSH/POP optimization (occurs in
   * switch statements):
   *    push.pri                xchg
   *    pop.alt                 -
   * Note that it is somewhat dangerous to do this, as
   * the original sequence keeps PRI and the new sequence
   * destroys it.
   */
  {
    #ifdef SCPACK
      "push.pri!pop.alt!",
      "xchg!",
    #else
      "\262\263",
      "\274",
    #endif
    2-1, 0-0
  },
  /* Redundant pushes (happens in some array operations)
   *    pop.alt                -
   *    push.alt               -
   */
  {
    #ifdef SCPACK
      "pop.alt!push.alt!",
      ";!",
    #else
      "\263\212\250",
      ";!",
    #endif
    2-0, 0-0
  },
  /* Some simple arithmetic sequences
   */
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!add!",
      "load.s.alt %1!add!",
    #else
      "\274\317\321",
      "\235\265\321",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!add!",
      "load.alt %1!add!",
    #else
      "\274\326\321",
      "\220\265\321",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!const.pri %1!add!",
      "const.alt %1!add!",
    #else
      "\274\304\321",
      "\247\265\321",
    #endif
    3-2, 1-1
  },
  /* References with a default value generate new cells on the heap
   * dynamically. That code often ends with:
   *    xchg                    push.alt
   *    push.pri                -
   */
  {
    #ifdef SCPACK
      "xchg!push.pri!",
      "push.alt!",
    #else
      "\274\262",
      "\212\250",
    #endif
    2-1, 0-0
  },
  /* Test for zero (common case, especially for strings)
   * E.g. the test expression of: "for (i=0; str{i}!=0; ++i)"
   *
   *    zero.alt                jzer %1
   *    eq                      -
   *    jnz %1                  -
   *    --------------------------------------
   *    zero.alt                jnz %1
   *    eq                      -
   *    jzer %1                 -
   *    --------------------------------------
   *    zero.alt                jzer %1
   *    neq                     -
   *    jzer %1                 -
   */
  {
    #ifdef SCPACK
      "zero.alt!eq!jnz %1!",
      "jzer %1!",
    #else
      "\347\250\322jnz\215",
      "\353",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.alt!eq!jzer %1!",
      "jnz %1!",
    #else
      "\347\250\322\353",
      "jnz\215",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.alt!neq!jzer %1!",
      "jzer %1!",
    #else
      "\347\250n\322\353",
      "\353",
    #endif
    3-1, 1-1
  },
  /* Array comparison has a NOT instruction that can sometimes be optimized away
   *    not                     jnz %1
   *    jzer %1                 -
   *    --------------------------------------
   *    not                     jzer %1
   *    jnz %1                  -
   */
  {
    #ifdef SCPACK
      "not!jzer %1!",
      "jnz %1!",
    #else
      "not!\353",
      "jnz\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "not!jnz %1!",
      "jzer %1!",
    #else
      "not!jnz\215",
      "\353",
    #endif
    2-1, 1-1
  },

  /* Incrementing and decrementing global and local variables, and reference
   * arguments may have redundant PUSH/POP instructions, for example when the
   * primary register is altered after restoring it, or at the end of an
   * expression.
   *    push.pri                load.s.pri %1   ; reference argument
   *    load.s.pri %1           inc.i
   *    inc.i                   lref.s.pri %2
   *    pop.pri                 -
   *    lref.s.pri %2           -
   *    --------------------------------------
   *    push.pri                load.s.pri %1
   *    load.s.pri %1           inc.i
   *    inc.i                   ;$exp
   *    pop.pri                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    push.pri                addr.pri %1     ; local variable
   *    addr.pri %1             inc.i
   *    inc.i                   load.s.pri %2
   *    pop.pri                 -
   *    load.s.pri %2           -
   *    --------------------------------------
   *    push.pri                const.pri %1    ; global variable
   *    const.pri %1            inc.i
   *    inc.i                   load.pri %2
   *    pop.pri                 -
   *    load.pri %2             -
   * The same is true for dec.i sequences.
   */
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!inc.i!pop.pri!lref.s.pri %2!",
      "load.s.pri %1!inc.i!lref.s.pri %2!",
    #else
      "\262\317\312\305\364\357\213\242",
      "\317\312\305\357\213\242",
    #endif
    5-3, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!inc.i!pop.pri!;$exp!",
      "load.s.pri %1!inc.i!;$exp!",
    #else
      "\262\317\312\305\364\257",
      "\317\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!inc.i!pop.pri!;load.s.pri %2!",
      "addr.pri %1!inc.i!;load.s.pri %2!",
    #else
      "\262\324\312\305\364;\266",
      "\324\312\305;\266",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!inc.i!pop.pri!;$exp!",
      "addr.pri %1!inc.i!;$exp!",
    #else
      "\262\324\312\305\364\257",
      "\324\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!inc.i!pop.pri!;load.pri %2!",
      "const.pri %1!inc.i!;load.pri %2!",
    #else
      "\262\304\312\305\364;\354",
      "\304\312\305;\354",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!inc.i!pop.pri!;$exp!",
      "const.pri %1!inc.i!;$exp!",
    #else
      "\262\304\312\305\364\257",
      "\304\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!dec.i!pop.pri!lref.s.pri %2!",
      "load.s.pri %1!dec.i!lref.s.pri %2!",
    #else
      "\262\317\314\305\364\357\213\242",
      "\317\314\305\357\213\242",
    #endif
    5-3, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!dec.i!pop.pri!;$exp!",
      "load.s.pri %1!dec.i!;$exp!",
    #else
      "\262\317\314\305\364\257",
      "\317\314\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!dec.i!pop.pri!;load.s.pri %2!",
      "addr.pri %1!dec.i!;load.s.pri %2!",
    #else
      "\262\324\314\305\364;\266",
      "\324\314\305;\266",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!dec.i!pop.pri!;$exp!",
      "addr.pri %1!dec.i!;$exp!",
    #else
      "\262\324\314\305\364\257",
      "\324\314\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!dec.i!pop.pri!;load.pri %2!",
      "const.pri %1!dec.i!;load.pri %2!",
    #else
      "\262\304\314\305\364;\354",
      "\304\314\305;\354",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!dec.i!pop.pri!;$exp!",
      "const.pri %1!dec.i!;$exp!",
    #else
      "\262\304\314\305\364\257",
      "\304\314\305\257",
    #endif
    4-2, 1-1
  },


  /* ----------------------------------- */
  /* Supplemental and macro instructions */
  /* ----------------------------------- */

  /* separator, so optimizer can stop before generating macro opcodes */
  { separator_macro, "", 0 },

  /* Array indexing can merit from special instructions.
   * Simple indexed array lookup can be optimized quite
   * a bit.
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               lidx.b %4
   *    shl.c.pri %4            -
   *    pop.alt                 -
   *    add                     -
   *    load.i                  -
   *
   * And to prepare for storing a value in an array
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               idxaddr.b %4
   *    shl.c.pri %4            -
   *    pop.alt                 -
   *    add                     -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent
   * 3. when "%4" (the shift value) is 2 (with 32-bit cells), use the
   *    even more optimal instructions LIDX and IDDXADDR
   *
   * If the array index is more complex, one can only optimize
   * the last four instructions:
   *    shl.c.pri %1            pop.alt
   *    pop.alt                 lidx.b %1
   *    add                     -
   *    loadi                   -
   *    --------------------------------------
   *    shl.c.pri %1            pop.alt
   *    pop.alt                 idxaddr.b %1
   *    add                     -
   */
#if !defined BIT16
  /* loading from array, "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\324\340\355\342\203\217\356\220\305",
      "\275\351\355l\335!",
    #endif
    8-4, 4-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\304\340\355\342\203\217\356\220\305",
      "\247\351\355l\335!",
    #endif
    8-4, 4-3
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx!",
    #else
      "\324\340\342\203\217\356\220\305",
      "\275\351l\335!",
    #endif
    7-3, 3-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx!",
    #else
      "\304\340\342\203\217\356\220\305",
      "\247\351l\335!",
    #endif
    7-3, 3-2
  },
#endif
  /* loading from array, not "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\324\340\355\342\230\307\356\220\305",
      "\275\351\355l\335.b\325",
    #endif
    8-4, 4-4
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\304\340\355\342\230\307\356\220\305",
      "\247\351\355l\335.b\325",
    #endif
    8-4, 4-4
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\324\340\342\2303!\356\220\305",
      "\275\351l\335.b\270",
    #endif
    7-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\304\340\342\2303!\356\220\305",
      "\247\351l\335.b\270",
    #endif
    7-3, 3-3
  },
#if !defined BIT16
  /* array index calculation for storing a value, "cell" aligned */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\324\340\355\342\203\217\356",
      "\275\351\355\335\244\227",
    #endif
    7-4, 4-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\304\340\355\342\203\217\356",
      "\247\351\355\335\244\227",
    #endif
    7-4, 4-3
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\324\340\342\203\217\356",
      "\275\351\335\244\227",
    #endif
    6-3, 3-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\304\340\342\203\217\356",
      "\247\351\335\244\227",
    #endif
    6-3, 3-2
  },
#endif
  /* array index calculation for storing a value, not "cell" packed */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\324\340\355\342\230\307\356",
      "\275\351\355\335\275.b\325",
    #endif
    7-4, 4-4
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\304\340\355\342\230\307\356",
      "\247\351\355\335\275.b\325",
    #endif
    7-4, 4-4
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\324\340\342\2303!\356",
      "\275\351\335\275.b\270",
    #endif
    6-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\304\340\342\2303!\356",
      "\247\351\335\275.b\270",
    #endif
    6-3, 3-3
  },
#if !defined BIT16
  /* the shorter array indexing sequences, see above for comments */
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!loadi!",
      "pop.alt!lidx!",
    #else
      "\342\203\217\356\220\225",
      "\263l\335!",
    #endif
    4-2, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!",
      "pop.alt!idxaddr!",
    #else
      "\342\203\217\356",
      "\263\335\244\227",
    #endif
    3-2, 1-0
  },
#endif
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!loadi!",
      "pop.alt!lidx.b %1!",
    #else
      "\342\226\356\220\225",
      "\263l\335.b\215",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!",
      "pop.alt!idxaddr.b %1!",
    #else
      "\342\226\356",
      "\263\335\275.b\215",
    #endif
    3-2, 1-1
  },
  /* Declaration of simple variables often follows the sequence:
   *    ;$lcl <name> <stk>      ;$lcl <name> <stk>
   *    stack -4                push.c <constval>
   *    const.pri <constval>    ;$exp
   *    stor.s <stk>            -
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!const.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!push.c %3!;$exp!",
    #else
      "\214lcl\336\234ack -\307\247\2303!\367\213\243\257",
      "\214lcl\336\361\270\257",
    #endif
    3-1, 3-1
  },
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!zero.pri!stor.s %2!;$exp!",
      ";$lcl %1 %2!push.c #0!;$exp!",
    #else
      "\214lcl\336\234ack -\307\347\240\367\213\243\257",
      "\214lcl\336\361\310\241\257",
    #endif
    3-1, 2-1
  },
#if 0
  /* When variables are declared and assigned a variable, the sequence is:
   *    ;$lcl <name> <stk>      ;$lcl <name> <stk>
   *    stack -4                stack -4
   *    load.pri <addr>         load.pri <addr>
   *    stor.s <stk>            stor.i
   *    ;$exp                   ;$exp
   */
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!load.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!stack #-4!load.pri %3!stor.i!;$exp!",
    #else
      "\214lcl\336\234ack -\307\220\2303!\367\213\243\257",
      "\214lcl\336\234ack\310-\307\220\2303!\367\305\257",
    #endif
    3-3, 3-2
  },
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!load.s.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!stack #-4!load.s.pri %3!stor.i!;$exp!",
    #else
      "\214lcl\336\234ack -\307\235\2303!\367\213\243\257",
      "\214lcl\336\234ack\310-\307\235\2303!\367\305\257",
    #endif
    3-3, 3-2
  },
#endif
  /* simple arithmetic sequences, involving subtraction */
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!sub!",
      "load.s.alt %1!sub.inv!",
    #else
      "\274\317sub!",
      "\235\265sub.\311v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!sub!",
      "load.alt %1!sub.inv!",
    #else
      "\274\326sub!",
      "\220\265sub.\311v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!const.pri %1!sub!",
      "const.alt %1!sub.inv!",
    #else
      "\274\304sub!",
      "\247\265sub.\311v!",
    #endif
    3-2, 1-1
  },
  /* optimizing the calling of native functions (which always have a parameter
   * count pushed before, and the stack pointer restored afterwards
   */
  {
    #ifdef SCPACK
      "push.c %1!sysreq %2!stack %3!",        //note: %3 == %1 + 4
      "sysreq.n %2 %1!",
    #else
      "\361\215sysr\302\243\234ack\270",
      "sysr\302.n\330\215",
    #endif
    3-1, 3-2
  },
  /* User-defined operators first load the operands into registers and
   * then have them pushed onto the stack. This can give rise to sequences
   * like:
   *    const.pri %1            push.c %1
   *    const.alt %2            push.c %2
   *    push.pri                -
   *    push.alt                -
   * A similar sequence occurs with the two PUSH.pri/alt instructions inverted.
   * The first, second, or both CONST.pri/alt instructions can also be
   * LOAD.pri/alt.
   * This gives 2 x 4 cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.pri!push.alt!",
      "push.c %1!push.c %2!",
    #else
      "\304\247\337\262\212\250",
      "\361\215\361\243",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push.c %1!",
    #else
      "\304\247\337\212\250\262",
      "\361\243\361\215",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.pri!push.alt!",
      "push.c %1!push %2!",
    #else
      "\304\220\337\262\212\250",
      "\361\215\212\243",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push.c %1!",
    #else
      "\304\220\337\212\250\262",
      "\212\243\361\215",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.pri!push.alt!",
      "push %1!push.c %2!",
    #else
      "\326\247\337\262\212\250",
      "\212\215\361\243",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push %1!",
    #else
      "\326\247\337\212\250\262",
      "\361\243\212\215",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.pri!push.alt!",
      "push %1!push %2!",
    #else
      "\326\220\337\262\212\250",
      "\212\215\212\243",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push %1!",
    #else
      "\326\220\337\212\250\262",
      "\212\243\212\215",
    #endif
    4-2, 2-2
  },
  /* Function calls (parameters are passed on the stack)
   *    load.s.pri %1           push.s %1
   *    push.pri                -
   *    --------------------------------------
   *    load.pri %1             push %1
   *    push.pri                -
   *    --------------------------------------
   *    const.pri %1            push.c %1
   *    push.pri                -
   *    --------------------------------------
   *    zero.pri                push.c 0
   *    push.pri                -
   *    --------------------------------------
   *    addr.pri %1             push.adr %1
   *    push.pri                -
   *
   * However, PRI must not be needed after this instruction
   * if this shortcut is used. Check for the ;$par comment.
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!;$par!",
      "push.s %1!;$par!",
    #else
      "\317\262\233",
      "\212\360\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!;$par!",
      "push %1!;$par!",
    #else
      "\326\262\233",
      "\212\215\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!;$par!",
      "push.c %1!;$par!",
    #else
      "\304\262\233",
      "\361\215\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!push.pri!;$par!",
      "push.c #0!;$par!",
    #else
      "\347\240\262\233",
      "\361\310\241\233",
    #endif
    2-1, 0-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!;$par!",
      "push.adr %1!;$par!",
    #else
      "\324\262\233",
      "\212\300\215\233",
    #endif
    2-1, 1-1
  },
  /* Native function calls with parameters that must be relocated.
   * Note that global variables cannot hold an address and therefore
   * no "pushr" instruction exists (a local variable holds an address
   * if that variable is a function argument that refers to an array).
   *
   *    load.s.pri %1           pushr.s %1
   *    pushr.pri               -
   *    --------------------------------------
   *    const.pri %1            pushr.c %1
   *    pushr.pri               -
   *    --------------------------------------
   *    zero.pri                pushr.c 0
   *    pushr.pri               -
   *    --------------------------------------
   *    addr.pri %1             pushr.adr %1
   *    pushr.pri               -
   *
   * Again, PRI must not be needed after this instruction
   * if this shortcut is used. Check for the ;$par comment.
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!pushr.pri!;$par!",
      "pushr.s %1!;$par!",
    #else
      "\317\253\240\233",
      "\253\360\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!pushr.pri!;$par!",
      "pushr.c %1!;$par!",
    #else
      "\304\253\240\233",
      "\253\236\215\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!pushr.pri!;$par!",
      "pushr.c #0!;$par!",
    #else
      "\347\240\253\240\233",
      "\253\236\310\241\233",
    #endif
    2-1, 0-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!pushr.pri!;$par!",
      "pushr.adr %1!;$par!",
    #else
      "\324\253\240\233",
      "\253\300\215\233",
    #endif
    2-1, 1-1
  },
  /* Simple arithmetic operations on constants. Subtraction is handled in
   * a separate section, because it is not commutative.
   *    const.alt %1            add.c %1
   *    add                     -
   *    --------------------------------------
   *    const.alt %1            smul.c %1
   *    smul                    -
   *    --------------------------------------
   *    const.alt %1            eq.c.pri %1
   *    eq                      -
   */
  {
    #ifdef SCPACK
      "const.alt %1!add!",
      "add.c %1!",
    #else
      "\247\265\321",
      "\244\236\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.alt %1!smul!",
      "smul.c %1!",
    #else
      "\247\265smul!",
      "smu\327\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.alt %1!eq!",
      "eq.c.pri %1!",
    #else
      "\247\265\322",
      "\302\236\226",
    #endif
    2-1, 1-1
  },
  /* Subtraction of a constant. Note that the subtraction is converted to
   * the addition of the inverse value.
   *    const.pri %1            load.s.pri %2
   *    load.s.alt %2           add.c -%1
   *    sub                     -
   *    --------------------------------------
   *    const.pri %1            load.pri %2
   *    load.alt %2             add.c -%1
   *    sub                     -
   */
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!sub!",
      "load.s.pri %2!add.c -%1!",
    #else
      "\304\235\337sub!",
      "\266\244\236 -\205",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!sub!",
      "load.pri %2!add.c -%1!",
    #else
      "\304\220\337sub!",
      "\354\244\236 -\205",
    #endif
    3-2, 2-2
  },
  /* With arrays indexed with constants that come from enumerations, it happens
   * multiple add.c opcodes follow in sequence.
   *    add.c %1                add.c %1+%2
   *    add.c %2                -
   */
  {
    #ifdef SCPACK
      "add.c %1!add.c %2!",
      "add.c %1+%2!",
    #else
      "\244\236\215\244\236\243",
      "\244\236\264+%\217",
    #endif
    2-1, 2-1
  },
  /* Compare and jump in chained and non-chained relation expressions.
   * The exchange operation may be removed on relation operators
   * by selecting the inverse relational operator
   *    xchg                    jsgeq  %1   also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    jzer %1                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      "xchg!sgrtr!jzer %1!;$exp!",
      "jsgeq %1!;$exp!",
    #else
      "\274\333rt\227\331\316",
      "j\333\302\316",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sless!jzer %1!;$exp!",
      "jsleq %1!;$exp!",
    #else
      "\274\334ess!\331\316",
      "j\334\302\316",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!jzer %1!;$exp!",
      "jsgrtr %1!;$exp!",
    #else
      "\274\333\322\331\316",
      "j\333rtr\316",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sleq!jzer %1!;$exp!",
      "jsless %1!;$exp!",
    #else
      "\274\334\322\331\316",
      "j\334ess\316",
    #endif
    3-1, 1-1
  },
  /* Standard compare and jump
   *    eq                      jneq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    eq                      jeq %1
   *    jnz %1                  -
   *    --------------------------------------
   *    neq                     jeq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    neq                     jneq %1
   *    jnz %1                  -
   * An similarly for other relations
   *    sless                   jsgeq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sless                   jsless %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sleq                    jsgrtr %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sleq                    jsleq %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sgrtr                   jsleq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sgrtr                   jsgrtr %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sgeq                    jsless %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sgeq                    jsgeq %1
   *    jnz %1                  -
   * We can relax the optimizations for the unsigned comparisons,
   * because the Pawn compiler currently only generates signed
   * comparisons.
   */
  {
    #ifdef SCPACK
      "eq!jzer %1!",
      "jneq %1!",
    #else
      "\322\353",
      "jn\302\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "eq!jnz %1!",
      "jeq %1!",
    #else
      "\322jnz\215",
      "j\302\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "neq!jzer %1!",
      "jeq %1!",
    #else
      "n\322\353",
      "j\302\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "neq!jnz %1!",
      "jneq %1!",
    #else
      "n\322jnz\215",
      "jn\302\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sless!jzer %1!",
      "jsgeq %1!",
    #else
      "\334ess!\353",
      "j\333\302\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sless!jnz %1!",
      "jsless %1!",
    #else
      "\334ess!jnz\215",
      "j\334ess\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sleq!jzer %1!",
      "jsgrtr %1!",
    #else
      "\334\322\353",
      "j\333rtr\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sleq!jnz %1!",
      "jsleq %1!",
    #else
      "\334\322jnz\215",
      "j\334\302\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgrtr!jzer %1!",
      "jsleq %1!",
    #else
      "\333rt\227\353",
      "j\334\302\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgrtr!jnz %1!",
      "jsgrtr %1!",
    #else
      "\333rt\227jnz\215",
      "j\333rtr\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgeq!jzer %1!",
      "jsless %1!",
    #else
      "\333\322\353",
      "j\334ess\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgeq!jnz %1!",
      "jsgeq %1!",
    #else
      "\333\322jnz\215",
      "j\333\302\215",
    #endif
    2-1, 1-1
  },
  /* select more appropriate INC and DEC opcodes
   *    addr.pri %1             inc.s %1
   *    inc.i                   -
   *    --------------------------------------
   *    const.pri %1            inc %1
   *    inc.i                   -
   * and the same for DEC
   */
  {
    #ifdef SCPACK
      "addr.pri %1!inc.i!",
      "inc.s %1!",
    #else
      "\324\312\305",
      "\312\360",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!inc.i!",
      "inc %1!",
    #else
      "\304\312\305",
      "\312\215",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!dec.i!",
      "dec.s %1!",
    #else
      "\324\314\305",
      "\314\360",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!dec.i!",
      "dec %1!",
    #else
      "\304\314\305",
      "\314\215",
    #endif
    2-1, 1-1
  },
  /* remove redundant PUSH/POP around an increment, if these
   * are (still) present
   *    push.pri                inc.s %1
   *    inc.s %1                -
   *    pop.pri                 -
   *    --------------------------------------
   *    push.pri                inc %1
   *    inc %1                  -
   *    pop.pri                 -
   * and the same for DEC
   */
  {
    #ifdef SCPACK
      "push.pri %1!inc.s %1!pop.pri!",
      "inc.s %1!",
    #else
      "\212\226\312\360\364",
      "\312\360",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!inc %1!pop.pri!",
      "inc %1!",
    #else
      "\212\226\312\215\364",
      "\312\215",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!dec.s %1!pop.pri!",
      "dec.s %1!",
    #else
      "\212\226\314\360\364",
      "\314\360",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!dec %1!pop.pri!",
      "dec %1!",
    #else
      "\212\226\314\215\364",
      "\314\215",
    #endif
    3-1, 1-1
  },
  /* Incrementing and decrementing leaves a value in
   * in PRI which may not be used (for example, as the
   * third expression in a "for" loop).
   *    inc %1                  inc %1  ; ++n
   *    load.pri %1             ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    load.pri %1             inc %1  ; n++, e.g. "for (n=0; n<10; n++)"
   *    inc %1                  ;$exp
   *    ;$exp                   -
   * Plus the varieties for stack relative increments
   * and decrements.
   */
  {
    #ifdef SCPACK
      "inc %1!load.pri %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "\312\215\326\257",
      "\312\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!inc %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "\326\312\316",
      "\312\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "inc.s %1!load.s.pri %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "\312\360\317\257",
      "\312\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!inc.s %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "\317\312\213\316",
      "\312\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "dec %1!load.pri %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "\314\215\326\257",
      "\314\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!dec %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "\326\314\316",
      "\314\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "dec.s %1!load.s.pri %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "\314\360\317\257",
      "\314\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!dec.s %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "\317\314\213\316",
      "\314\213\316",
    #endif
    2-1, 2-1
  },
  /* Loading the constant zero has a special opcode.
   * When storing zero in memory, the value of PRI must not be later on.
   *    const.pri 0             zero %1
   *    stor %1                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.s %1
   *    stor.s %1               ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero %1
   *    stor %1                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero.s %1
   *    stor.s %1               ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.pri
   *    --------------------------------------
   *    const.alt 0             zero.alt
   * The last two alternatives save more memory than they save
   * time, but anyway...
   */
  {
    #ifdef SCPACK
      "const.pri 0!stor %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\247\203\241\367\316",
      "\347\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "const.pri 0!stor.s %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\247\203\241\367\213\316",
      "\347\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "zero.pri!stor %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\347\240\367\316",
      "\347\316",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!stor.s %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\347\240\367\213\316",
      "\347\213\316",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri +0!",
      "zero.pri!",
    #else
      "\247\203+\241",
      "\347\240",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.alt +0!",
      "zero.alt!",
    #else
      "\247\223 +\241",
      "\347\250",
    #endif
    1-1, 1-0
  },
  /* ----- */
  /* Functions with many parameters with the same "type" have sequences like:
   *    push.c %1               pushm.c 3 %1 %2 %3
   *    ;$par                   ;$par
   *    push.c %2               -
   *    ;$par                   -
   *    push.c %3               -
   *    ;$par                   -
   *    etc.                    etc.
   *
   * Similar sequences occur with PUSH, PUSH.s and PUSHADDR, plus
   * PUSHR.c, PUSHR.s and PUSHR.adr
   */
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!;$par!push.c %5!;$par!",
      "pushm.c #5 %1 %2 %3 %4 %5!",
    #else
      "\361\215\303\236\243\303\236\270\303\236\325\303\236\206\320\233",
      "\323\236\3105\376\2064\206\320",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!;$par!",
      "pushm.c #4 %1 %2 %3 %4!",
    #else
      "\361\215\303\236\243\303\236\270\303\236\325\233",
      "\323\236\3104\376\325",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!",
      "pushm.c #3 %1 %2 %3!",
    #else
      "\361\215\303\236\243\303\236\270\233",
      "\323\236\3103\352\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!",
      "pushm.c #2 %1 %2!",
    #else
      "\361\215\303\236\243\233",
      "\323\236\3102\336",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!;$par!push %5!;$par!",
      "pushm #5 %1 %2 %3 %4 %5!",
    #else
      "\212\215\303\243\303\270\303\325\303\206\320\233",
      "\323\3105\376\2064\206\320",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!;$par!",
      "pushm #4 %1 %2 %3 %4!",
    #else
      "\212\215\303\243\303\270\303\325\233",
      "\323\3104\376\325",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!",
      "pushm #3 %1 %2 %3!",
    #else
      "\212\215\303\243\303\270\233",
      "\323\3103\352\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!",
      "pushm #2 %1 %2!",
    #else
      "\212\215\303\243\233",
      "\323\3102\336",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!;$par!push.s %5!;$par!",
      "pushm.s #5 %1 %2 %3 %4 %5!",
    #else
      "\212\360\303\213\243\303\213\270\303\213\325\303\213\206\320\233",
      "\323\213\3105\376\2064\206\320",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!;$par!",
      "pushm.s #4 %1 %2 %3 %4!",
    #else
      "\212\360\303\213\243\303\213\270\303\213\325\233",
      "\323\213\3104\376\325",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!",
      "pushm.s #3 %1 %2 %3!",
    #else
      "\212\360\303\213\243\303\213\270\233",
      "\323\213\3103\352\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!",
      "pushm.s #2 %1 %2!",
    #else
      "\212\360\303\213\243\233",
      "\323\213\3102\336",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!;$par!push.adr %5!;$par!",
      "pushm.adr #5 %1 %2 %3 %4 %5!",
    #else
      "\212\300\215\303\300\243\303\300\270\303\300\325\303\300\206\320\233",
      "\323\300\3105\376\2064\206\320",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!;$par!",
      "pushm.adr #4 %1 %2 %3 %4!",
    #else
      "\212\300\215\303\300\243\303\300\270\303\300\325\233",
      "\323\300\3104\376\325",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!",
      "pushm.adr #3 %1 %2 %3!",
    #else
      "\212\300\215\303\300\243\303\300\270\233",
      "\323\300\3103\352\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!",
      "pushm.adr #2 %1 %2!",
    #else
      "\212\300\215\303\300\243\233",
      "\323\300\3102\336",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!pushr.c %4!;$par!pushr.c %5!;$par!",
      "pushrm.c #5 %1 %2 %3 %4 %5!",
    #else
      "\253\236\215\315\236\243\315\236\270\315\236\325\315\236\206\320\233",
      "\362\236\3105\376\2064\206\320",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!pushr.c %4!;$par!",
      "pushrm.c #4 %1 %2 %3 %4!",
    #else
      "\253\236\215\315\236\243\315\236\270\315\236\325\233",
      "\362\236\3104\376\325",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!",
      "pushrm.c #3 %1 %2 %3!",
    #else
      "\253\236\215\315\236\243\315\236\270\233",
      "\362\236\3103\352\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!",
      "pushrm.c #2 %1 %2!",
    #else
      "\253\236\215\315\236\243\233",
      "\362\236\3102\336",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!pushr.s %4!;$par!pushr.s %5!;$par!",
      "pushrm.s #5 %1 %2 %3 %4 %5!",
    #else
      "\253\360\315\213\243\315\213\270\315\213\325\315\213\206\320\233",
      "\362\213\3105\376\2064\206\320",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!pushr.s %4!;$par!",
      "pushrm.s #4 %1 %2 %3 %4!",
    #else
      "\253\360\315\213\243\315\213\270\315\213\325\233",
      "\362\213\3104\376\325",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!",
      "pushrm.s #3 %1 %2 %3!",
    #else
      "\253\360\315\213\243\315\213\270\233",
      "\362\213\3103\352\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!",
      "pushrm.s #2 %1 %2!",
    #else
      "\253\360\315\213\243\233",
      "\362\213\3102\336",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!pushr.adr %4!;$par!pushr.adr %5!;$par!",
      "pushrm.adr #5 %1 %2 %3 %4 %5!",
    #else
      "\253\300\215\315\300\243\315\300\270\315\300\325\315\300\206\320\233",
      "\362\300\3105\376\2064\206\320",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!pushr.adr %4!;$par!",
      "pushrm.adr #4 %1 %2 %3 %4!",
    #else
      "\253\300\215\315\300\243\315\300\270\315\300\325\233",
      "\362\300\3104\376\325",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!",
      "pushrm.adr #3 %1 %2 %3!",
    #else
      "\253\300\215\315\300\243\315\300\270\233",
      "\362\300\3103\352\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!",
      "pushrm.adr #2 %1 %2!",
    #else
      "\253\300\215\315\300\243\233",
      "\362\300\3102\336",
    #endif
    2-1, 2-3
  },
  /* Loading two registers at a time
   *    load.pri %1             load2 %1 %2
   *    load.alt %2             -
   *    --------------------------------------
   *    load.alt %2             load2 %1 %2
   *    load.pri %1             -
   *    --------------------------------------
   *    load.s.pri %1           load2.s %1 %2
   *    load.s.alt %2           -
   *    --------------------------------------
   *    load.s.alt %2           load2.s %1 %2
   *    load.s.pri %1           -
   */
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!",
      "load2 %1 %2!",
    #else
      "\326\220\337",
      "\2202\336",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.alt %2!load.pri %1!",
      "load2 %1 %2!",
    #else
      "\220\337\326",
      "\2202\336",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!",
      "load2.s %1 %2!",
    #else
      "\317\235\337",
      "\2202\213\336",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.alt %2!load.s.pri %1!",
      "load2.s %1 %2!",
    #else
      "\235\337\317",
      "\2202\213\336",
    #endif
    2-1, 2-2
  },
  /* Loading two registers and then pushing them occurs with user operators
   *    load2 %1 %2            pushm 2 %1 %2
   *    push.pri                -
   *    push.alt                -
   *    --------------------------------------
   *    load2.s %1 %2          pushm.s 2 %1 %2
   *    push.pri                -
   *    push.alt                -
   */
  {
    #ifdef SCPACK
      "load2 %1 %2!push.pri!push.alt!",
      "pushm #2 %1 %2!",
    #else
      "\2202\336\262\212\250",
      "\323\3102\336",
    #endif
    3-1, 2-3
  },
  {
    #ifdef SCPACK
      "load2.s %1 %2!push.pri!push.alt!",
      "pushm.s #2 %1 %2!",
    #else
      "\2202\213\336\262\212\250",
      "\323\213\3102\336",
    #endif
    3-1, 2-3
  },
  /* Load a constant in a variable
   *    const.pri %1            const %2 %1
   *    stor %2                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri %1            const.s %2 %1
   *    stor.s %2               ;$exp
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      "const.pri %1!stor %2!;$exp!",
      "const %2 %1!;$exp!",
    #else
      "\304\367\243\257",
      "\247\330\316",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!stor.s %2!;$exp!",
      "const.s %2 %1!;$exp!",
    #else
      "\304\367\213\243\257",
      "\247\213\330\316",
    #endif
    2-1, 2-2
  },


  /* ------------------ */
  /* Packed opcodes     */
  /* ------------------ */

  /* separator, so optimizer can stop before generating macro opcodes */
  { separator_full, "", 0 },

  /* If %0 is in the range cell_min .. cell_max, do conversions like:
   *    add.c %0                add.p.c %0
   *
   * Rules in this section may only use %0 (a special symbol which matches
   * a numeric cell in a restricted range and replaces it with a shorter
   * representation of the same value).
   */

  {
    #ifdef SCPACK
      "load.pri %0!",
      "load.p.pri %0!",
    #else
      "\220\365",
      "\220\224\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.alt %0!",
      "load.p.alt %0!",
    #else
      "\220\375",
      "\220\224\375",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.s.pri %0!",
      "load.p.s.pri %0!",
    #else
      "\235\365",
      "\220\224\213\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.s.alt %0!",
      "load.p.s.alt %0!",
    #else
      "\235\375",
      "\220\224\213\375",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lref.s.pri %0!",
      "lref.p.s.pri %0!",
    #else
      "\357\213\365",
      "\357\224\213\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lref.s.alt %0!",
      "lref.p.s.alt %0!",
    #else
      "\357\213\375",
      "\357\224\213\375",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lodb.i %0!",
      "lodb.p.i %0!",
    #else
      "\216db.\200%\241",
      "\216db\224.\200%\241",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.pri %0!",
      "const.p.pri %0!",
    #else
      "\247\365",
      "\247\224\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.alt %0!",
      "const.p.alt %0!",
    #else
      "\247\375",
      "\247\224\375",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "addr.pri %0!",
      "addr.p.pri %0!",
    #else
      "\275\365",
      "\275\224\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "addr.alt %0!",
      "addr.p.alt %0!",
    #else
      "\275\375",
      "\275\224\375",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stor %0!",
      "stor.p %0!",
    #else
      "\367\260",
      "\367\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stor.s %0!",
      "stor.p.s %0!",
    #else
      "\367\374",
      "\367\224\374",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "sref.s %0!",
      "sref.p.s %0!",
    #else
      "s\346\374",
      "s\346\224\374",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "strb.i %0!",
      "strb.p.i %0!",
    #else
      "\234rb.\200%\241",
      "\234rb\224.\200%\241",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lidx.b %0!",
      "lidx.p.b %0!",
    #else
      "l\335.b\260",
      "l\335\224.b\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "idxaddr.b %0!",
      "idxaddr.p.b %0!",
    #else
      "\335\275.b\260",
      "\335\275\224.b\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "align.pri %0!",
      "align.p.pri %0!",
    #else
      "\221ign\365",
      "\221ign\224\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.c %0!",
      "push.p.c %0!",
    #else
      "\361\260",
      "\212\224\236\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push %0!",
      "push.p %0!",
    #else
      "\212\260",
      "\212\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.s %0!",
      "push.p.s %0!",
    #else
      "\212\374",
      "\212\224\374",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.adr %0!",
      "push.p.adr %0!",
    #else
      "\212\300\260",
      "\212\224\300\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.c %0!",
      "pushr.p.c %0!",
    #else
      "\253\236\260",
      "\253\224\236\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.s %0!",
      "pushr.p.s %0!",
    #else
      "\253\374",
      "\253\224\374",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.adr %0!",
      "pushr.p.adr %0!",
    #else
      "\253\300\260",
      "\253\224\300\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.c %0 %1~%2~%3~%4~%5!",
      "pushm.p.c %0 %1~%2~%3~%4~%5!",
    #else
      "\323\236\373\264\371\372\2674\267\320",
      "\323\224\236\373\264\371\372\2674\267\320",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm %0 %1~%2~%3~%4~%5!",
      "pushm.p %0 %1~%2~%3~%4~%5!",
    #else
      "\323\373\264\371\372\2674\267\320",
      "\323\224\373\264\371\372\2674\267\320",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.s %0 %1~%2~%3~%4~%5!",
      "pushm.p.s %0 %1~%2~%3~%4~%5!",
    #else
      "\323\213\373\264\371\372\2674\267\320",
      "\323\224\213\373\264\371\372\2674\267\320",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.adr %0 %1~%2~%3~%4~%5!",
      "pushm.p.adr %0 %1~%2~%3~%4~%5!",
    #else
      "\323\300\373\264\371\372\2674\267\320",
      "\323\224\300\373\264\371\372\2674\267\320",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.c %0 %1~%2~%3~%4~%5!",
      "pushrm.p.c %0 %1~%2~%3~%4~%5!",
    #else
      "\362\236\373\264\371\372\2674\267\320",
      "\362\224\236\373\264\371\372\2674\267\320",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.s %0 %1~%2~%3~%4~%5!",
      "pushrm.p.s %0 %1~%2~%3~%4~%5!",
    #else
      "\362\213\373\264\371\372\2674\267\320",
      "\362\224\213\373\264\371\372\2674\267\320",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.adr %0 %1~%2~%3~%4~%5!",
      "pushrm.p.adr %0 %1~%2~%3~%4~%5!",
    #else
      "\362\300\373\264\371\372\2674\267\320",
      "\362\224\300\373\264\371\372\2674\267\320",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stack %0!",
      "stack.p %0!",
    #else
      "\234ack\260",
      "\234ack\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "heap %0!",
      "heap.p %0!",
    #else
      "heap\260",
      "heap\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.pri %0!",
      "shl.p.c.pri %0!",
    #else
      "\342\365",
      "\210l\224\236\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.alt %0!",
      "shl.p.c.alt %0!",
    #else
      "\342\375",
      "\210l\224\236\375",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "add.c %0!",
      "add.p.c %0!",
    #else
      "\244\236\260",
      "\244\224\236\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "smul.c %0!",
      "smul.p.c %0!",
    #else
      "smu\327\260",
      "smul\224\236\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "zero %0!",
      "zero.p %0!",
    #else
      "\347\260",
      "\347\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "zero.s %0!",
      "zero.p.s %0!",
    #else
      "\347\374",
      "\347\224\374",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "eq.c.pri %0!",
      "eq.p.c.pri %0!",
    #else
      "\302\236\365",
      "\302\224\236\365",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "eq.c.alt %0!",
      "eq.p.c.alt %0!",
    #else
      "\302\236\375",
      "\302\224\236\375",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "inc %0!",
      "inc.p %0!",
    #else
      "\312\260",
      "\312\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "inc.s %0!",
      "inc.p.s %0!",
    #else
      "\312\374",
      "\312\224\374",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "dec %0!",
      "dec.p %0!",
    #else
      "\314\260",
      "\314\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "dec.s %0!",
      "dec.p.s %0!",
    #else
      "\314\374",
      "\314\224\374",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "movs %0!",
      "movs.p %0!",
    #else
      "movs\260",
      "movs\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "cmps %0!",
      "cmps.p %0!",
    #else
      "cmps\260",
      "cmps\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "fill %0!",
      "fill.p %0!",
    #else
      "fill\260",
      "fill\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "halt %0!",
      "halt.p %0!",
    #else
      "h\222\260",
      "h\222\224\260",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "bounds %0!",
      "bounds.p %0!",
    #else
      "\350\260",
      "\350\224\260",
    #endif
    1-1, 1-0
  },

  /* ----- */
  { NULL, NULL, 0 }
};
